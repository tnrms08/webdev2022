# 01-1. 자료구조에 대한 기본적인 이해

## 1. 자료구조

- 자료구조 : ‘데이터의 저장’을 담당하는 것

- 자료구조의 분류

    |선형구조|비선형구조|파일구조|단순구조|
    |:---:|:---:|:---:|:---:|
    |리스트|트리|순차파일|정수|
    |스택|그래프|직접파일|실수|
    |큐||색인파일|문자|
    ||||문자열|

# 01-2. 알고리즘의 성능분석 방법

## 1. 알고리즘

표현 및 저장된 데이터를 대상으로 하는 문제의 해결 방법

최적 : 적은 메모리 사용, 빠른 속도

## 2. 시간 복잡도와 공간 복잡도

알고리즘을 평가하는 요소

1. 시간복잡도
    
    속도에 해당하는 알고리즘의 수행시간 분석결과
    
    연산의 횟수를 통해서 알고리즘의 빠르기 판단
    
    알고리즘 별 연산 횟수를 함수의 형태로 구성하여 데이터 수의 증가에 따른 연산횟수의 변화 정도 파악 ⇒ 둘 이상의 알고리즘 비교에 용이
    
    <aside>
    데이터의 수가 많아짐에 따른 연산횟수의 증가 정도
    
    </aside>
    
2. 공간복잡도
    
    메모리 사용량에 대한 분석결과
    

## 3. 순차 탐색 알고리즘과 시간 복잡도

- 순차탐색 : 맨 앞에서부터 순서대로 탐색을 진행하는 알고리즘

```c
//주요 알고리즘
for(i=0; i<len; i++)
{
	if(ar[i] == target)
		return i;
}
```

- 핵심 : 동등비교를 하는 비교 연산
    
    값의 동등을 비교하는 == 연산을 적게 수행하는 탐색 알고리즘이 좋은 탐색 알고리즘
    
- 시간복잡도 계산
    1. 최악의 경우
        
        $$
        T(n)=n
        $$
        
    2. 평균적인 경우
        
        $$
        T(n)
            =\frac{3}{4}n
        $$
        
        최악의 경우에 비해서 상대적으로 시간 복잡도를 구하는 것이 쉽지 않다.
        
        시간 복잡도 함수는 신뢰도가 높지 않다.
        
    
    ⇒ ‘최악의 경우’를 시간 복잡도의 기준으로 삼는다.
    

## 4. 이진 탐색 알고리즘과 시간 복잡도

- 이진 탐색 알고리즘 : 탐색의 대상을 반복해서 반씩 떨구어 내는 알고리즘

```c
//주요 알고리즘
while(first <= last)
{
	mid = (first+last)/2;

	if(target == arr[mid]){
		return mid;
	}	else{
		if(target < arr[mid])
			last = mid-1;
		else
			first = mid+1;
	}
	return -1;
}
```

- 시간복잡도 계산
    1. 최악의 경우
        
        ==연산 : 연산횟수를 대표하는 연산
        
        $$
        T(n) = log_2n
        $$
        

## 5. 빅-오 표기법

- 데이터 수의 증가에 따른 연산횟수의 증가 형태를 표현한 것
    
    (=데이터 수의 증가에 따른 연산횟수의 증가율의 상한선을 표현한 것)
    

<aside>
💡 T(n)이 다항식으로 표현된 경우, 최고차항의 차수가 빅-오가 된다.

</aside>

- 대표적인 빅-오 표기들의 성능의 대소관계

$$
O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)
$$

- 수학적 접근

> 두 개의 함수 f(n)과 g(n)이 주어졌을 때, 모든 n≥K에 대하여 f(n)≤Cg(n)을 만족하는 두 개의 상수 C와 K가 존재한다면, f(n)의 빅-오는 O(g(n))이다.
>